# Plan filesystem-ultra en 3 l√≠neas:

Backups accesibles: Crear backups en C:\Users\DAVID\AppData\Local\Temp\mcp-batch-backups (ruta permitida por MCP) antes de cada operaci√≥n destructiva (edit/delete/batch).
Protecci√≥n anti-sobrescritura: Validar impacto antes de editar - si cambia >30% del archivo o >50 ocurrencias, requerir analyze_edit primero o force: true.
Restauraci√≥n: Nuevas tools list_backups(), restore_backup(backup_id, file?) y compare_with_backup() para recuperar archivos da√±ados.


# Por qu√© se debe realizar:

Perdiste c√≥digo: Batch operations sobrescribi√≥ archivos y no pudiste recuperarlos desde el backup porque estaba en ruta inaccesible para MCP.
Riesgo actual: Cualquier edit_file o batch_operations puede destruir archivos sin forma de deshacer, dependes 100% de Git para recuperar.
Prevenci√≥n: Con backups accesibles + validaci√≥n + restauraci√≥n, tienes red de seguridad antes de que Git sea la √∫ltima opci√≥n.





# Plan de Desarrollo para filesystem-ultra
FASE 1: Sistema de Backup Mejorado
1.1 Ubicaci√≥n de backups accesible
rust// src/operations/backup.rs

// Crear backups en ubicaci√≥n accesible por MCP
fn get_backup_dir() -> PathBuf {
    PathBuf::from(env::var("MCP_BACKUP_DIR")
        .unwrap_or("C:\\Users\\DAVID\\AppData\\Local\\Temp\\mcp-batch-backups".to_string()))
}

// Backup individual con metadata
pub fn create_backup(file_path: &Path) -> Result<BackupInfo> {
    let backup_dir = get_backup_dir().join(chrono::Local::now().format("%Y%m%d-%H%M%S"));
    let relative_path = file_path.strip_prefix(workspace)?;
    let backup_path = backup_dir.join(relative_path);
    
    // Copiar archivo
    fs::copy(file_path, &backup_path)?;
    
    // Guardar metadata
    let metadata = BackupMetadata {
        original_path: file_path.to_string(),
        backup_path: backup_path.to_string(),
        timestamp: chrono::Local::now(),
        file_size: fs::metadata(file_path)?.len(),
        operation: "edit", // o "delete", "batch"
    };
    
    Ok(BackupInfo { path: backup_path, metadata })
}
1.2 Backup autom√°tico en todas las operaciones destructivas
rust// Antes de: edit_file, delete_file, batch_operations
let backup = create_backup(&file_path)?;
log::info!("üîí Backup creado: {}", backup.path.display());

FASE 2: Protecci√≥n contra Cambios Masivos
2.1 Detecci√≥n de cambios en edit_file / recovery_edit
rustpub fn calculate_change_impact(content: &str, old_text: &str, new_text: &str) -> ChangeImpact {
    let total_lines = content.lines().count();
    let old_occurrences = content.matches(old_text).count();
    let chars_changed = old_occurrences * (old_text.len() + new_text.len());
    let change_percentage = (chars_changed as f64 / content.len() as f64) * 100.0;
    
    ChangeImpact {
        lines_total: total_lines,
        occurrences: old_occurrences,
        change_percentage,
        is_risky: change_percentage > 30.0 || old_occurrences > 50,
    }
}
2.2 Validaci√≥n antes de ejecutar
rust// En recovery_edit / intelligent_edit
let impact = calculate_change_impact(&content, old_text, new_text);

if impact.is_risky {
    return Err(format!(
        "‚ö†Ô∏è RIESGO ALTO: Se modificar√° {:.1}% del archivo ({} ocurrencias)\n\
         Usa 'analyze_edit' primero o confirma con force: true",
        impact.change_percentage, impact.occurrences
    ));
}

// Crear backup autom√°tico
let backup = create_backup(&path)?;

FASE 3: Herramientas de Restauraci√≥n
3.1 Nueva tool: list_backups
rust#[tool(description = "Lista backups disponibles con metadata")]
async fn list_backups(
    limit: Option<usize> // Default: 20
) -> Result<Value> {
    let backup_dir = get_backup_dir();
    let backups = scan_backups(&backup_dir)?
        .into_iter()
        .take(limit.unwrap_or(20))
        .collect();
    
    json!({
        "backups": backups,
        "location": backup_dir
    })
}
3.2 Nueva tool: restore_backup
rust#[tool(description = "Restaura archivo(s) desde backup")]
async fn restore_backup(
    backup_id: String,      // timestamp del backup
    file_path: Option<String>, // archivo espec√≠fico o todos
    preview: bool           // mostrar diff antes de restaurar
) -> Result<Value> {
    let backup_dir = get_backup_dir().join(&backup_id);
    
    if preview {
        return show_restore_diff(&backup_dir, &file_path)?;
    }
    
    // Restaurar con confirmaci√≥n
    restore_files(&backup_dir, &file_path)?;
    
    json!({ "status": "restored", "files": files_restored })
}
3.3 Nueva tool: compare_with_backup
rust#[tool(description = "Compara archivo actual vs backup")]
async fn compare_with_backup(
    backup_id: String,
    file_path: String
) -> Result<Value> {
    let current = fs::read_to_string(&file_path)?;
    let backup_file = get_backup_dir().join(&backup_id).join(&file_path);
    let backup = fs::read_to_string(&backup_file)?;
    
    let diff = create_unified_diff(&backup, &current);
    
    json!({
        "diff": diff,
        "lines_changed": count_changed_lines(&diff)
    })
}

FASE 4: Configuraci√≥n
4.1 Actualizar claude_desktop_config.json
json{
  "mcpServers": {
    "filesystem-ultra": {
      "command": "...",
      "args": ["..."],
      "env": {
        "ALLOWED_PATHS": "C:\\__REPOS;C:\\Users\\DAVID\\AppData\\Local\\Temp\\mcp-batch-backups",
        "MCP_BACKUP_DIR": "C:\\Users\\DAVID\\AppData\\Local\\Temp\\mcp-batch-backups"
      }
    }
  }
}

RESUMEN DE NUEVAS TOOLS:
markdown‚úÖ list_backups(limit?)
   ‚Üí Lista backups con timestamp, archivos, tama√±o

‚úÖ restore_backup(backup_id, file_path?, preview?)
   ‚Üí Restaura desde backup con diff opcional

‚úÖ compare_with_backup(backup_id, file_path)
   ‚Üí Muestra diff entre backup y actual

‚úÖ cleanup_backups(older_than_days: 7)
   ‚Üí Elimina backups antiguos

CAMBIOS EN TOOLS EXISTENTES:
rust// recovery_edit / intelligent_edit / edit_file
+ Backup autom√°tico antes de editar
+ Validaci√≥n de impact (warn si >30% cambia)
+ Opci√≥n force: true para bypass

// batch_operations
+ Backup de todos los archivos afectados
+ validate_only mejorado con change_impact
+ force: true para cambios masivos

// delete_file
+ Backup obligatorio antes de borrar
+ Mover a .trash/ en lugar de borrar permanente